From 7497aef025e432dd6253cace49bcbea2536aadbb Mon Sep 17 00:00:00 2001
From: Vladimir Prus <vladimir@codesourcery.com>
Date: Fri, 12 Dec 2008 05:51:53 +0900
Subject: [PATCH] SH: Implement MOVCO.L and MOVLI.L

* target-sh4/cpu.h (struct CPUSH4State): New field ldst.
	* target-sh4/helper.c (do_interrupt): Initialize ldst.
	* target-sh4/translate.c (cpu_ldst): New.
	(sh4_translate_init): Initialize cpu_ldst.
	(_decode_opc): Support MOVCO.L and MOVLI.L.

Signed-off-by: Vladimir Prus <vladimir@codesourcery.com>
Signed-off-by: Paul Mundt <lethal@linux-sh.org>
---
 target-sh4/cpu.h       |    2 ++
 target-sh4/helper.c    |    1 +
 target-sh4/translate.c |   34 +++++++++++++++++++++++++++++++++-
 3 files changed, 36 insertions(+), 1 deletions(-)

Index: qemu/target-sh4/cpu.h
===================================================================
--- qemu.orig/target-sh4/cpu.h
+++ qemu/target-sh4/cpu.h
@@ -139,6 +139,8 @@ typedef struct CPUSH4State {
     uint32_t prr;		/* Processor Revision Register */
     uint32_t cvr;		/* Cache Version Register */
 
+    uint32_t ldst;
+
      CPU_COMMON tlb_t utlb[UTLB_SIZE];	/* unified translation table */
     tlb_t itlb[ITLB_SIZE];	/* instruction translation table */
     void *intc_handle;
Index: qemu/target-sh4/helper.c
===================================================================
--- qemu.orig/target-sh4/helper.c
+++ qemu/target-sh4/helper.c
@@ -160,6 +160,7 @@ void do_interrupt(CPUState * env)
     env->spc = env->pc;
     env->sgr = env->gregs[15];
     env->sr |= SR_BL | SR_MD | SR_RB;
+    env->ldst = 0;
 
     if (env->flags & (DELAY_SLOT | DELAY_SLOT_CONDITIONAL)) {
         /* Branch instruction should be executed again before delay slot. */
Index: qemu/target-sh4/translate.c
===================================================================
--- qemu.orig/target-sh4/translate.c
+++ qemu/target-sh4/translate.c
@@ -72,7 +72,7 @@ static TCGv_ptr cpu_env;
 static TCGv cpu_gregs[24];
 static TCGv cpu_pc, cpu_sr, cpu_ssr, cpu_spc, cpu_gbr;
 static TCGv cpu_vbr, cpu_sgr, cpu_dbr, cpu_mach, cpu_macl;
-static TCGv cpu_pr, cpu_fpscr, cpu_fpul;
+static TCGv cpu_pr, cpu_fpscr, cpu_fpul, cpu_ldst;
 static TCGv cpu_fregs[32];
 
 /* internal register indexes */
@@ -144,6 +144,8 @@ static void sh4_translate_init(void)
     cpu_delayed_pc = tcg_global_mem_new_i32(TCG_AREG0,
 					    offsetof(CPUState, delayed_pc),
 					    "_delayed_pc_");
+    cpu_ldst = tcg_global_mem_new_i32(TCG_AREG0,
+				      offsetof(CPUState, ldst), "_ldst_");
 
     for (i = 0; i < 32; i++)
         cpu_fregs[i] = tcg_global_mem_new_i32(TCG_AREG0,
@@ -1543,6 +1545,36 @@ static void _decode_opc(DisasContext * c
     case 0x0029:		/* movt Rn */
 	tcg_gen_andi_i32(REG(B11_8), cpu_sr, SR_T);
 	return;
+    case 0x0073:
+        /* MOVCO.L
+	       LDST -> T
+               If (T == 1) R0 -> (Rn)
+               0 -> LDST
+        */
+        if (ctx->features & SH_FEATURE_SH4A) {
+	    int label = gen_new_label();
+	    gen_clr_t();
+	    tcg_gen_or_i32(cpu_sr, cpu_sr, cpu_ldst);
+	    tcg_gen_brcondi_i32(TCG_COND_EQ, cpu_ldst, 0, label);
+	    tcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);
+	    gen_set_label(label);
+	    tcg_gen_movi_i32(cpu_ldst, 0);
+	    return;
+	} else
+	    break;
+    case 0x0063:
+        /* MOVLI.L @Rm,R0
+               1 -> LDST
+               (Rm) -> R0
+               When interrupt/exception
+               occurred 0 -> LDST
+        */
+	if (ctx->features & SH_FEATURE_SH4A) {
+	    tcg_gen_movi_i32(cpu_ldst, 1);
+	    tcg_gen_qemu_ld32s(REG(0), REG(B11_8), ctx->memidx);
+	    return;
+	} else
+	    break;
     case 0x0093:		/* ocbi @Rn */
 	{
 	    TCGv dummy = tcg_temp_new();
