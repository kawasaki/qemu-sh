From 008f04e3881af6e3d3ad6f03bb84a00cf6e5c63a Mon Sep 17 00:00:00 2001
From: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date: Thu, 11 Dec 2008 13:09:07 +0900
Subject: [PATCH] SH7750/51: add register BCR3, NCR4, PCR, RTCOR, RTCNT, RTCSR, SDMR2, SDMR3 and fix BCR2 support

Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Signed-off-by: Paul Mundt <lethal@linux-sh.org>
---
 hw/sh7750.c          |   59 +++++++++++++++++++++++++++++++++++++++++++++++--
 hw/sh7750_regnames.c |    2 +
 hw/sh7750_regs.h     |   11 +++++++++
 3 files changed, 69 insertions(+), 3 deletions(-)

Index: qemu/hw/sh7750.c
===================================================================
--- qemu.orig/hw/sh7750.c
+++ qemu/hw/sh7750.c
@@ -42,8 +42,12 @@ typedef struct SH7750State {
     uint32_t periph_freq;
     /* SDRAM controller */
     uint32_t bcr1;
-    uint32_t bcr2;
+    uint16_t bcr2;
+    uint16_t bcr3;
+    uint32_t bcr4;
     uint16_t rfcr;
+    /* PCMCIA controller */
+    uint16_t pcr;
     /* IO ports */
     uint16_t gpioic;
     uint32_t pctra;
@@ -66,7 +70,10 @@ typedef struct SH7750State {
     struct intc_desc intc;
 } SH7750State;
 
-
+static int inline is_sh7751r_cpu(SH7750State * s)
+{
+	return (s->cpu->id & (SH_CPU_SH7751R));
+}
 /**********************************************************************
  I/O ports
 **********************************************************************/
@@ -211,8 +218,17 @@ static uint32_t sh7750_mem_readw(void *o
     switch (addr) {
     case SH7750_BCR2_A7:
 	return s->bcr2;
+    case SH7750_BCR3_A7:
+	if(is_sh7751r_cpu(s)) {
+	    return s->bcr3;
+	} else {
+	    error_access("word read", addr);
+	    assert(0);
+	}
     case SH7750_FRQCR_A7:
 	return 0;
+    case SH7750_PCR_A7:
+	return s->pcr;
     case SH7750_RFCR_A7:
 	fprintf(stderr,
 		"Read access to refresh count register, incrementing\n");
@@ -221,6 +237,11 @@ static uint32_t sh7750_mem_readw(void *o
 	return porta_lines(s);
     case SH7750_PDTRB_A7:
 	return portb_lines(s);
+    case SH7750_RTCOR_A7:
+    case SH7750_RTCNT_A7:
+    case SH7750_RTCSR_A7:
+	ignore_access("word read", addr);
+	return 0;
     default:
 	error_access("word read", addr);
 	assert(0);
@@ -235,6 +256,12 @@ static uint32_t sh7750_mem_readl(void *o
     case SH7750_BCR1_A7:
 	return s->bcr1;
     case SH7750_BCR4_A7:
+	if(is_sh7751r_cpu(s)) {
+	    return s->bcr4;
+	} else {
+	    error_access("long read", addr);
+	    assert(0);
+	}
     case SH7750_WCR1_A7:
     case SH7750_WCR2_A7:
     case SH7750_WCR3_A7:
@@ -271,9 +298,17 @@ static uint32_t sh7750_mem_readl(void *o
     }
 }
 
+#define is_in_sdrmx(a, x) (a >= SH7750_SDMR ## x ## _A7 \
+			&& a <= (SH7750_SDMR ## x ## _A7 + SH7750_SDMR ## x ## _REGNB))
 static void sh7750_mem_writeb(void *opaque, target_phys_addr_t addr,
 			      uint32_t mem_value)
 {
+
+    if (is_in_sdrmx(addr, 2) || is_in_sdrmx(addr, 3)) {
+	ignore_access("word write", addr);
+	return;
+    }
+
     switch (addr) {
 	/* PRECHARGE ? XXXXX */
     case SH7750_PRECHARGE0_A7:
@@ -298,8 +333,18 @@ static void sh7750_mem_writew(void *opaq
         s->bcr2 = mem_value;
         return;
     case SH7750_BCR3_A7:
-    case SH7750_RTCOR_A7:
+	if(is_sh7751r_cpu(s)) {
+	    s->bcr3 = mem_value;
+	    return;
+	} else {
+	    error_access("word write", addr);
+	    assert(0);
+	}
+    case SH7750_PCR_A7:
+	s->pcr = mem_value;
+	return;
     case SH7750_RTCNT_A7:
+    case SH7750_RTCOR_A7:
     case SH7750_RTCSR_A7:
 	ignore_access("word write", addr);
 	return;
@@ -343,6 +388,14 @@ static void sh7750_mem_writel(void *opaq
         s->bcr1 = mem_value;
         return;
     case SH7750_BCR4_A7:
+	if(is_sh7751r_cpu(s)) {
+	    s->bcr4 = mem_value;
+	    return;
+	} else {
+	    error_access("long write", addr);
+	    assert(0);
+	}
+        return;
     case SH7750_WCR1_A7:
     case SH7750_WCR2_A7:
     case SH7750_WCR3_A7:
Index: qemu/hw/sh7750_regnames.c
===================================================================
--- qemu.orig/hw/sh7750_regnames.c
+++ qemu/hw/sh7750_regnames.c
@@ -79,6 +79,8 @@ static regname_t regnames[] = {
 	REGNAME(SH7750_ICR_A7)
 	REGNAME(SH7750_BCR3_A7)
 	REGNAME(SH7750_BCR4_A7)
+	REGNAME(SH7750_SDMR2_A7)
+	REGNAME(SH7750_SDMR3_A7)
 	REGNAME(SH7750_PRECHARGE0_A7)
     REGNAME(SH7750_PRECHARGE1_A7) {(uint32_t) - 1, 0}
 };
Index: qemu/hw/sh7750_regs.h
===================================================================
--- qemu.orig/hw/sh7750_regs.h
+++ qemu/hw/sh7750_regs.h
@@ -979,6 +979,17 @@
 
 #define SH7750_RFCR_KEY       0xA400	/* RFCR write key */
 
+/* Synchronous DRAM mode registers - SDMR */
+#define SH7750_SDMR2_REGOFS   0x900000	/* base offset */
+#define SH7750_SDMR2_REGNB    0x0FFC	/* nb of register */
+#define SH7750_SDMR2          SH7750_P4_REG32(SH7750_SDMR2_REGOFS)
+#define SH7750_SDMR2_A7       SH7750_A7_REG32(SH7750_SDMR2_REGOFS)
+
+#define SH7750_SDMR3_REGOFS   0x940000	/* offset */
+#define SH7750_SDMR3_REGNB    0x0FFC	/* nb of register */
+#define SH7750_SDMR3          SH7750_P4_REG32(SH7750_SDMR3_REGOFS)
+#define SH7750_SDMR3_A7       SH7750_A7_REG32(SH7750_SDMR3_REGOFS)
+
 /*
  * Direct Memory Access Controller (DMAC)
  */
