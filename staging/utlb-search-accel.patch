Index: trunk/target-sh4/cpu.h
===================================================================
--- trunk/target-sh4/cpu.h	(revision 6628)
+++ trunk/target-sh4/cpu.h	(working copy)
@@ -145,13 +145,16 @@
     uint32_t pvr;		/* Processor Version Register */
     uint32_t prr;		/* Processor Revision Register */
     uint32_t cvr;		/* Cache Version Register */
 
     uint32_t ldst;
 
-     CPU_COMMON tlb_t utlb[UTLB_SIZE];	/* unified translation table */
+    CPU_COMMON
+    tlb_t utlb[UTLB_SIZE];	/* unified translation table */
+    tlb_t * sorted_utlb[UTLB_SIZE];
+    uint32_t sorted_utlb_num;
     tlb_t itlb[ITLB_SIZE];	/* instruction translation table */
     void *intc_handle;
     int intr_at_halt;		/* SR_BL ignored during sleep */
     store_request_t *store_requests;
     store_request_t **store_request_tail;
 } CPUSH4State;
Index: trunk/target-sh4/helper.c
===================================================================
--- trunk/target-sh4/helper.c	(revision 6628)
+++ trunk/target-sh4/helper.c	(working copy)
@@ -323,7 +323,7 @@
     if (e == MMU_DTLB_MULTIPLE)
 	e = MMU_ITLB_MULTIPLE;
     else if (e == MMU_DTLB_MISS && update) {
-	e = find_tlb_entry(env, address, env->utlb, UTLB_SIZE, use_asid);
+	e = find_utlb_entry(env, address, use_asid);
 	if (e >= 0) {
 	    tlb_t * ientry;
 	    n = itlb_replacement(env);
@@ -343,15 +343,69 @@
     return e;
 }
 
+static inline int is_utlb_match(tlb_t * e, uint32_t addr)
+{
+    return (e->vpn << 10 & ~(e->size - 1)) == (addr & ~(e->size - 1));
+}
+
 /* Find utlb entry
    Return entry, MMU_DTLB_MISS, MMU_DTLB_MULTIPLE */
 int find_utlb_entry(CPUState * env, target_ulong address, int use_asid)
 {
+    int min = 0;
+    int max = env->sorted_utlb_num - 1;
+    int cur = (min + max) / 2 ;
+    int save;
+    uint8_t asid = env->pteh & 0xff;
+    int ret = MMU_DTLB_MISS;
+
     /* per utlb access */
     increment_urc(env);
 
-    /* Return entry */
-    return find_tlb_entry(env, address, env->utlb, UTLB_SIZE, use_asid);
+    if (env->sorted_utlb_num <= 0)
+	return MMU_DTLB_MISS;
+
+    /* binary search */
+    while (!is_utlb_match(env->sorted_utlb[cur], address)) {
+	if (min >= max)
+	    return MMU_DTLB_MISS;
+	if (((env->sorted_utlb[cur]->vpn << 10)
+	    & ~(env->sorted_utlb[cur]->size - 1)) <
+	    (address & ~(env->sorted_utlb[cur]->size - 1))) {
+	    min = cur + 1;
+	} else {
+	    max = cur - 1;
+	}
+	cur = (min + max) / 2;
+    }
+
+    save = cur;
+
+    /* minus search */
+    do {
+	tlb_t * e = env->sorted_utlb[cur];
+	if (e->sh || (!use_asid) || e->asid == asid) {
+	    if (ret != MMU_DTLB_MISS)
+		return MMU_DTLB_MULTIPLE;
+	    ret = e - &env->utlb[0];
+	}
+	cur--;
+    } while(cur >= 0 && is_utlb_match(env->sorted_utlb[cur], address));
+
+    /* plus search */
+    cur = save + 1;
+    while (cur < env->sorted_utlb_num &&
+	   is_utlb_match(env->sorted_utlb[cur], address)) {
+	tlb_t * e = env->sorted_utlb[cur];
+	if (e->sh || (!use_asid) || e->asid == asid) {
+	    if (ret != MMU_DTLB_MISS)
+		return MMU_DTLB_MULTIPLE;
+	    ret = e - &env->utlb[0];
+	}
+	cur++;
+    } 
+
+    return ret;
 }
 
 /* Match address against MMU
@@ -526,6 +580,63 @@
     return physical;
 }
 
+static void add_entry_to_sorted_utlb(CPUState * env, tlb_t * entry)
+{
+    int i;
+
+    if (env->sorted_utlb_num == 0) {
+	env->sorted_utlb[0] = entry;
+	env->sorted_utlb_num = 1;
+	return;
+    }
+
+    if (entry->vpn <= env->sorted_utlb[0]->vpn) {
+	memmove(&env->sorted_utlb[1],
+		&env->sorted_utlb[0],
+		sizeof(tlb_t *) * env->sorted_utlb_num);
+	env->sorted_utlb[0] = entry;
+	env->sorted_utlb_num++;
+	return;
+    }
+
+    for (i = 0; i < env->sorted_utlb_num - 1; i++) {
+	tlb_t * e1 = env->sorted_utlb[i];
+	tlb_t * e2 = env->sorted_utlb[i + 1];
+	if (e1->vpn <= entry->vpn && entry->vpn <= e2->vpn) {
+	    memmove(&env->sorted_utlb[i + 2],
+		    &env->sorted_utlb[i + 1],
+		    sizeof(tlb_t *) * (env->sorted_utlb_num - i - 1));
+	    env->sorted_utlb[i + 1] = entry;
+	    env->sorted_utlb_num++;
+	    return;
+	}
+    }
+
+#if 0
+    assert(env->sorted_utlb_num < UTLB_SIZE);
+#endif
+    env->sorted_utlb[env->sorted_utlb_num] = entry;
+    env->sorted_utlb_num++;
+}
+
+static void remove_entry_from_sorted_utlb(CPUState * env, tlb_t * entry)
+{
+    int i;
+#if 0
+    assert(env->sorted_utlb_num > 0);
+#endif
+
+    for (i = 0; i < env->sorted_utlb_num; i++) {
+	if (env->sorted_utlb[i] == entry) {
+	    env->sorted_utlb_num--;
+	    memmove(&env->sorted_utlb[i],
+		    &env->sorted_utlb[i + 1],
+		    sizeof(tlb_t *) * (env->sorted_utlb_num - i));
+	    return;
+	}
+    }
+}
+
 void cpu_load_tlb(CPUState * env)
 {
     int n = cpu_mmucr_urc(env->mmucr);
@@ -537,6 +648,8 @@
 	if (!same_tlb_entry_exists(env->itlb, ITLB_SIZE, entry)) {
 	    tlb_flush_page(env, address);
 	}
+
+	remove_entry_from_sorted_utlb(env, entry);
     }
 
     /* Take values into cpu status from registers. */
@@ -569,6 +682,9 @@
     entry->wt   = (uint8_t)cpu_ptel_wt(env->ptel);
     entry->sa   = (uint8_t)cpu_ptea_sa(env->ptea);
     entry->tc   = (uint8_t)cpu_ptea_tc(env->ptea);
+
+    /* add to sorted list */
+    add_entry_to_sorted_utlb(env, entry);
 }
 
 void cpu_sh4_write_mmaped_utlb_addr(CPUSH4State *s, target_phys_addr_t addr,
@@ -600,8 +716,12 @@
 		    s->tea = addr;
 		    break;
 	        }
-		if (entry->v && !v)
+		if (entry->v && !v) {
 		    needs_tlb_flush = 1;
+		    remove_entry_from_sorted_utlb(s, entry);
+		} else if (!entry->v && v){
+		    add_entry_to_sorted_utlb(s, entry);
+		}
 		entry->v = v;
 		entry->d = d;
 	        utlb_match_entry = entry;
@@ -636,6 +756,7 @@
 	    if (!same_tlb_entry_exists(s->itlb, ITLB_SIZE, entry)) {
 	        tlb_flush_page(s, address);
 	    }
+	    remove_entry_from_sorted_utlb(s, entry);
 	}
 	entry->asid = asid;
 	entry->vpn = vpn;
